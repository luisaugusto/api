import { Client, isFullPage } from "@notionhq/client";
import type {
  PageObjectResponse,
  PartialDatabaseObjectResponse,
  PartialPageObjectResponse,
} from "@notionhq/client/build/src/api-endpoints.js";
import type { VercelRequest, VercelResponse } from "@vercel/node";
import ical, { ICalAlarmType, ICalCalendarMethod } from "ical-generator";

const notion = new Client({ auth: process.env.NOTION_TOKEN ?? "" });

enum Prop {
  Status = "Status",
  AllDay = "AllDay",
  Date = "Date",
  Category = "Category",
  Location = "Location",
  URL = "URL",
  Notes = "Notes",
  Name = "Name",
}

const fetchAllPages = async (
  database_id: string,
  pages: (PartialPageObjectResponse | PartialDatabaseObjectResponse)[] = [],
  start_cursor?: string,
): Promise<(PartialPageObjectResponse | PartialDatabaseObjectResponse)[]> => {
  const resp = await notion.databases.query({
    database_id,
    ...(start_cursor ? { start_cursor } : {}),
  });

  if (resp.has_more && resp.next_cursor) {
    return fetchAllPages(
      database_id,
      pages.concat(resp.results),
      resp.next_cursor,
    );
  }

  return pages.concat(resp.results);
};

type NotionPropertyValue = PageObjectResponse["properties"][string];
export const getProp = <T extends NotionPropertyValue["type"]>(
  props: PageObjectResponse["properties"],
  prop: Prop,
  type: T,
): Extract<NotionPropertyValue, { type: T }> | null =>
  props[prop]?.type === type
    ? (props[prop] as Extract<NotionPropertyValue, { type: T }>)
    : null;

type NotionDate = Extract<NotionPropertyValue, { type: "date" }>["date"];

interface Props {
  allDay: boolean;
  category: string | undefined;
  date: NotionDate | undefined;
  location: string;
  notes: string;
  status: string;
  url: string | null;
  title: string;
}

const getProps = (properties: PageObjectResponse["properties"]): Props => {
  const status = String(
    getProp(properties, Prop.Status, "status")?.status?.name,
  );
  const allDay = Boolean(
    getProp(properties, Prop.AllDay, "checkbox")?.checkbox,
  );
  const date = getProp(properties, Prop.Date, "date")?.date;
  const category = getProp(properties, Prop.Category, "select")?.select?.name;
  const location =
    getProp(properties, Prop.Location, "rich_text")
      ?.rich_text.map((text) => text.plain_text)
      .join("") ?? "";
  const url = getProp(properties, Prop.URL, "url")?.url ?? null;
  const notes =
    getProp(properties, Prop.Notes, "rich_text")
      ?.rich_text.map((text) => text.plain_text)
      .join("") || "";
  const title =
    (["Scheduled", "Reserved"].includes(status) ? "" : "[Pending] ") +
    String(
      getProp(properties, Prop.Name, "title")
        ?.title.map((text) => text.plain_text)
        .join(""),
    );

  return { allDay, category, date, location, notes, status, title, url };
};

const isValidEvent = (
  props: Props,
  date?: NotionDate,
): date is NonNullable<NotionDate> =>
  props.status !== "Cancelled" &&
  props.category !== "Flights" &&
  date?.start !== null;

export default async function handler(
  req: VercelRequest,
  res: VercelResponse,
): Promise<void> {
  try {
    const { db: database_id } = req.query;

    if (!database_id) {
      res.status(400).json({
        error: "Missing required query param: db (Notion database ID)",
      });
      return;
    }

    const pages = await fetchAllPages(String(database_id));

    const cal = ical({
      method: ICalCalendarMethod.PUBLISH,
      name: "Notion Calendar",
    });

    pages.forEach((page) => {
      if (!isFullPage(page)) return;

      const props = getProps(page.properties);

      const { date } = props;
      if (!isValidEvent(props, date)) return;

      const start = new Date(date.start);
      const end = new Date(date?.end || start.getTime() + 60 * 60 * 1000);

      const event = cal.createEvent({
        allDay: props.allDay,
        description: props.notes,
        end,
        location: props.location,
        start,
        summary: props.title,
        timezone: date.time_zone,
        url: props.url,
      });

      // Alarms: 1h before for timed; 1 day before for all-day
      // We detect all-day either via explicit checkbox or by Notion start lacking time (heuristic)
      if (props.allDay) {
        event.createAlarm({
          triggerBefore: 24 * 60 * 60,
          type: ICalAlarmType.display,
        });
      } else {
        event.createAlarm({
          triggerBefore: 60 * 60,
          type: ICalAlarmType.display,
        });
      }

      // UID & DTSTAMP are auto-generated by ical-generator unless overridden
      event.id(`${page.id}@notion`);
      event.stamp(new Date());
    });

    res.setHeader("Content-Type", "text/calendar; charset=utf-8");
    // Cache briefly; calendar clients will poll
    res.setHeader("Cache-Control", "public, max-age=300");
    res.status(200).send(cal.toString());
  } catch (error) {
    console.error(error);
    res.status(500).json({ detail: String(error), error: "Internal error" });
  }
}
