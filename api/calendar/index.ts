import type { VercelRequest, VercelResponse } from "@vercel/node";
import {
  fetchAllPages,
  getDateRange,
  getProps,
  isValidEvent,
} from "./utils.js";
import ical, {
  ICalAlarmType,
  ICalCalendar,
  ICalCalendarMethod,
} from "ical-generator";
import { NotionResponse } from "./types.js";
import { isFullPage } from "@notionhq/client";

const createEvent = (page: NotionResponse, cal: ICalCalendar): void => {
  if (!isFullPage(page)) return;

  const props = getProps(page.properties);

  const { date } = props;
  if (!isValidEvent(props, date)) return;

  const { endDate, startDate } = getDateRange(date, props.allDay);

  const event = cal.createEvent({
    allDay: props.allDay,
    description: props.notes,
    end: endDate,
    location: props.location,
    start: startDate,
    summary: props.title,
    timezone: date.time_zone,
    url: props.url,
  });

  // Alarms: 1h before for timed; 1 day before for all-day
  // We detect all-day either via explicit checkbox or by Notion start lacking time (heuristic)
  event.createAlarm({
    triggerBefore: props.allDay ? 24 * 60 * 60 : 60 * 60,
    type: ICalAlarmType.display,
  });

  // UID & DTSTAMP are auto-generated by ical-generator unless overridden
  event.id(`${page.id}@notion`);
  event.stamp(new Date());
};

const successResponse = (res: VercelResponse, cal: string): void => {
  res.setHeader("Content-Type", "text/calendar; charset=utf-8");
  res.setHeader("Cache-Control", "public, max-age=300");
  res.status(200).send(cal.toString());
};

export default async function handler(
  req: VercelRequest,
  res: VercelResponse,
): Promise<void> {
  try {
    const { db: database_id } = req.query;

    if (!database_id) {
      res.status(400).json({
        error: "Missing required query param: db (Notion database ID)",
      });
      return;
    }

    const pages = await fetchAllPages(String(database_id));

    const cal = ical({
      method: ICalCalendarMethod.PUBLISH,
      name: "Notion Calendar",
    });

    pages.forEach((page) => createEvent(page, cal));
    successResponse(res, cal.toString());
  } catch (error) {
    res.status(500).json({ detail: String(error), error: "Internal error" });
  }
}
